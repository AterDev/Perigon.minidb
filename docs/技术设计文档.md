# 📄 微型内存数据库引擎技术设计文档（MiniDB）

## 1. 项目概述
本项目目标是实现一个轻量级、单文件、关系型内存数据库引擎，专用于小数据量（≤50MB文件）。

特点：
- **全内存操作**：启动时一次性将数据文件加载到内存，所有查询和修改基于内存对象集合。
- **共享内存缓存**：同一数据库文件的多个 DbContext 实例共享同一份内存数据，而非各自维护副本。
- **增量持久化写入**：修改或删除数据后，只将变更部分更新到文件，而不是全量写入。
- **单线程文件写入队列**：所有文件更新通过专用的 `FileWriteQueue` 串行执行，避免磁盘写冲突和数据损坏。
- **多线程安全读取**：多个线程可同时读取共享内存集合。
- **异步支持**：提供完整的异步 API（`SaveChangesAsync`、`IAsyncDisposable`）。
- **简化功能**：无外键、无索引、无复杂数据约束。
- **API 类似 EF Core**，但不依赖 EF Core。
- **采用固定长度二进制格式存储**，支持真正的增量更新（O(1)寻址）。
- **序列化封装在内部**，用户无需为实体类添加任何序列化特性。

适用场景：
- 小型桌面应用、本地工具存储、嵌入式脚本配置。
- 数据量不超过十万记录，文件体积 ≤ 50MB。

---

## 2. 技术目标

### 2.1 支持功能
- 单文件本地存储
- 全量内存加载（≤50MB）
- **共享内存架构**：同一文件的所有 DbContext 实例共享同一份内存数据
- **单线程文件写入队列**：保证文件操作的串行化和一致性
- 增量文件更新（修改/删除时仅更新对应记录）
- 多线程同时读取
- **完整异步支持**（async/await）
- 类型安全实体模型（无序列化注解暴露给用户）
- 提供类似 EF Core 的 DbContext 抽象层，支持 LINQ 查询

❌ 不支持：
- 外键关系
- 复杂索引与约束
- SQL 解析器
- 存储过程 / 触发器 / 视图
- 数据库内事务隔离（由 SaveChanges 替代）

---

## 3. 架构设计

### 3.1 高层架构
```
──────────── 应用层（用户代码） ─────────────
 MicroDbContext (用户自定义派生类)
 DbSet<TEntity> (表集合，LINQ 查询)
─────────────────────────────────────────
 引擎核心
  • SharedDataCache（跨 DbContext 的共享内存）
  • FileDataCache（单个文件的内存缓存 + 写队列）
  • FileWriteQueue（单线程文件写入队列）
  • ChangeTracker（增量变更记录）
  • StorageManager（文件读/写，增量更新）
─────────────────────────────────────────
 底层支持
  • Lock / SemaphoreSlim（.NET 9+ 高性能锁）
  • 固定长度二进制编解码（内部）
  • 文件IO（单线程更新队列）
  • 内存集合（List<TEntity>）
─────────────────────────────────────────
```

### 3.2 核心设计理念

#### 3.2.1 共享内存架构
```
数据库文件: data.mds
    ↓
[SharedDataCache] (静态单例)
    ↓
FileDataCache (一个文件一个实例)
    ├── 内存数据：Dictionary<TableName, List<Entity>>
    ├── 读写锁：Lock / SemaphoreSlim
    └── 写入队列：FileWriteQueue
    ↓
多个 DbContext 实例共享同一 FileDataCache
    DbContext #1 ──┐
    DbContext #2 ──┼── 共享读取内存数据
    DbContext #3 ──┘
```

**关键特性**：
- DbContext **不拥有**内存数据，只是访问共享缓存
- DbContext **不直接**操作文件，所有写入通过 `FileWriteQueue` 串行化
- 多个 DbContext 实例看到的是**同一份内存数据**，无需手动刷新
- 内存数据的生命周期**独立于** DbContext 实例
- 通过 `MicroDbContext.ReleaseSharedCache(filePath)` 显式释放内存

#### 3.2.2 单线程文件写入队列
```
SaveChanges() 调用
    ↓
将写入操作加入 FileWriteQueue
    ↓
Channel<WriteOperation> (无界通道)
    ↓
单个后台线程串行执行所有文件写入
    ↓
操作完成后通知调用者（TaskCompletionSource）
```

**优势**：
- **消除文件锁冲突**：只有一个线程操作文件句柄
- **保证写入顺序**：先调用 SaveChanges 的操作一定先写入
- **简化错误处理**：失败时只需处理单个线程的异常
- **支持异步**：调用者可 await 写入完成，不阻塞其他操作

---

## 4. 详细需求设计

### 4.1 数据存储模型

#### 文件结构（固定长度二进制格式）
```
┌──────────────────────────────────────────────────────┐
│ 文件头 (256字节，固定长度)                           │
│ - 魔法数: "MDB1" (4字节)                             │
│ - 版本号: 1 (2字节)                                  │
│ - 表数量: N (2字节)                                  │
│ - 保留: (248字节，用于扩展)                          │
├──────────────────────────────────────────────────────┤
│ 表元数据区 (每表128字节，N×128字节)                 │
│ 每个表项:                                            │
│ - 表名: "Users" (64字节，固定长度)                  │
│ - 记录数: (4字节)                                    │
│ - 记录大小: 128 (4字节，固定长度)                    │
│ - 数据起始位置: (8字节)                              │
│ - 保留: (48字节)                                     │
├──────────────────────────────────────────────────────┤
│ 表1数据区 (每条记录固定长度)                        │
│ [记录1][记录2][记录3]...                             │
│ [IsDeleted(1B)][Id(4B)][Data(NB)]                   │
├──────────────────────────────────────────────────────┤
│ 表2数据区                                            │
│ ...                                                  │
└──────────────────────────────────────────────────────┘
```

#### 记录结构示例
```csharp
// User 表：包含支持的所有类型
public class User
{
    public int Id { get; set; }                      // 4字节
    
    [MaxLength(50)]
    public string Name { get; set; }                 // 50字节 (UTF-8)
    
    [MaxLength(100)]
    public string Email { get; set; }                // 100字节 (UTF-8)
    
    public DateTime CreatedAt { get; set; }          // 8字节 (UTC Ticks)
    
    public decimal Balance { get; set; }             // 16字节
    
    public bool IsActive { get; set; }               // 1字节
    
    public int? CategoryId { get; set; }             // 5字节 (1标记+4值)
    
    public DateTime? PublishedAt { get; set; }       // 9字节 (1标记+8值)
    
    // IsDeleted: 1字节 (由框架管理)
}
```

#### 核心优势
- **O(1) 寻址**：`offset = tableStartPos + (recordId - 1) * recordSize`
- **直接覆写**：修改任意字段，只需定位并覆写该记录，无级联位移
- **快速删除**：只需设置 `IsDeleted` 标记位，无需重写整个文件
- **预知文件大小**：支持文件预分配，避免动态扩展碎片

---

### 4.2 MicroDbContext 使用方式

#### 基本用法
```csharp
// 创建上下文（自动共享内存缓存）
await using var db = new MicroDbContext("data.mds");

// 添加数据
db.Users.Add(new User { Name = "Alice", Email = "alice@example.com" });
await db.SaveChangesAsync(); // 通过写入队列异步写入

// 查询（基于共享内存）
var adults = db.Users.Where(u => u.Age >= 18).ToList();

// 上下文销毁时不会释放共享内存
// 内存数据仍然保留，下次创建上下文时立即可用
```

#### 显式释放内存
```csharp
// 当确实需要释放内存时（例如应用关闭前）
await MicroDbContext.ReleaseSharedCacheAsync("data.mds");
// 或同步版本
MicroDbContext.ReleaseSharedCache("data.mds");
```

#### MicroDbContext 职责：
- 访问共享的 `FileDataCache`（不拥有）
- 管理所有 `DbSet` 表集合
- 跟踪实体对象的增删改（ChangeTracker）
- 调用 StorageManager 通过写入队列执行文件更新
- **不负责**：内存缓存的生命周期管理

---

### 4.3 DbSet<TEntity>
- 内存集合的操作接口：
  - `Add(TEntity entity)` → 标记为新增
  - `Remove(TEntity entity)` → 标记为删除
  - `Update(TEntity entity)` → 标记为修改
- LINQ查询直接遍历共享内存集合。
- `IEnumerable<TEntity>` 提供标准集合功能。
- 所有改动由 ChangeTracker 记录，用于增量写入。
- 操作时获取读/写锁，保证线程安全。

---

### 4.4 ChangeTracker（增量变更跟踪）
数据结构：
```csharp
class ChangeTracker
{
    // 使用 HashSet 提供 O(1) 查找性能
    private readonly HashSet<object> _added;
    private readonly HashSet<object> _modified;
    private readonly HashSet<object> _deleted;
    private readonly Lock _syncRoot;

    public IReadOnlyList<object> Added { get; }
    public IReadOnlyList<object> Modified { get; }
    public IReadOnlyList<object> Deleted { get; }

    public void Clear();
}
```
- 保存未提交的变更。
- SaveChanges/SaveChangesAsync：
  1. 进入写锁。
  2. 将写入操作加入 `FileWriteQueue`。
  3. 等待写入完成（TaskCompletionSource）。
  4. 成功后清空记录。
  5. 失败则抛出异常（调用者决定是否重试）。

---

### 4.5 增量更新机制
- 每条记录在文件中有唯一 ID 和物理偏移地址。
- 修改/删除时：
  - 根据 ID 定位文件的偏移位置。
  - 通过 `FileWriteQueue` 串行执行覆写操作。
  - 删除记录标记为"无效"（IsDeleted=1），等待压缩。
- 新增记录直接追加到该表区域末尾。
- **所有文件操作通过单线程队列串行化**。

---

### 4.6 线程安全设计

#### 内存数据访问
- 使用 `Lock` 类型（.NET 9+）提供高性能锁
- 同步锁：`Lock.Enter()` / `Lock.Exit()`
- 异步锁：`SemaphoreSlim` 用于 async 方法
- 多线程可并发读共享内存集合
- 写入操作获取独占锁

#### 文件写入队列
```csharp
class FileWriteQueue
{
    private readonly Channel<WriteOperation> _writeChannel;
    private readonly Task _writerTask; // 单个后台线程
    
    public async Task QueueWriteAsync(Func<Task> writeAction)
    {
        var operation = new WriteOperation(writeAction);
        await _writeChannel.Writer.WriteAsync(operation);
        await operation.CompletionSource.Task; // 等待完成
    }
}
```

**优势**：
- 消除文件句柄竞争
- 保证写入顺序
- 支持异步等待
- 自动批处理（Channel 缓冲）

---

### 4.7 序列化与字段映射

#### 支持的数据类型

| 类型 | 固定大小 | 编码规则 |
|------|--------|--------|
| `int` | 4 字节 | 小端字节序（BitConverter） |
| `int?` | 5 字节 | 1字节 null 标记 + 4字节值 |
| `bool` | 1 字节 | 0x00=false, 0x01=true |
| `bool?` | 2 字节 | 1字节 null 标记 + 1字节值 |
| `string` | 可变* | UTF-8 编码，由 `[MaxLength]` 指定，默认 1024 字节 |
| `decimal` | 16 字节 | .NET decimal 二进制格式 |
| `decimal?` | 17 字节 | 1字节 null 标记 + 16字节值 |
| `DateTime` | 8 字节 | UTC 时间戳，Ticks 格式 |
| `DateTime?` | 9 字节 | 1字节 null 标记 + 8字节值 |

#### 性能优化
- **FrozenDictionary/FrozenSet**：元数据缓存使用冻结集合
- **Span<T> / stackalloc**：临时缓冲区零分配
- **ArrayPool<byte>**：读取缓冲区复用
- **CollectionsMarshal**：List 内部数组直接访问

---

## 5. API 设计示例

### 5.1 基本用法
```csharp
// 实体模型（用户无需任何序列化特性）
public class User
{
    public int Id { get; set; }
    
    [MaxLength(50)]
    public string Name { get; set; }
    
    public int Age { get; set; }
    
    public decimal Balance { get; set; }
    
    public DateTime CreatedAt { get; set; }
    
    public int? CategoryId { get; set; }
}

// 定义 DbContext
public class MyDbContext(string filePath) : MicroDbContext(filePath)
{
    public DbSet<User> Users { get; set; } = null!;
}

// 使用（异步推荐）
await using var ctx = new MyDbContext("data.mds");

// 添加
ctx.Users.Add(new User 
{ 
    Name = "Alice", 
    Age = 30,
    Balance = 1000m,
    CreatedAt = DateTime.UtcNow,
    CategoryId = 5
});
await ctx.SaveChangesAsync();

// 查询（基于共享内存）
var activeUsers = ctx.Users
    .Where(u => u.Balance >= 500)
    .OrderByDescending(u => u.CreatedAt)
    .ToList();

// 修改
var user = ctx.Users.First();
user.Balance += 100;
ctx.Users.Update(user);
await ctx.SaveChangesAsync();

// 删除
ctx.Users.Remove(user);
await ctx.SaveChangesAsync();
```

### 5.2 内存管理
```csharp
// 创建多个上下文（共享内存）
await using var db1 = new MyDbContext("data.mds");
await using var db2 = new MyDbContext("data.mds");
// db1 和 db2 看到的是同一份内存数据

// 显式释放内存（应用关闭前）
await MyDbContext.ReleaseSharedCacheAsync("data.mds");
// 或同步版本
MyDbContext.ReleaseSharedCache("data.mds");
```

---

## 6. 性能优化方向

### 6.1 已实现的优化
1. **共享内存架构**
   - 避免重复加载和内存浪费
   - 多个上下文实例共享同一份数据

2. **单线程文件写入队列**
   - 消除文件锁竞争和数据损坏风险
   - 自动批处理提高吞吐量

3. **增量写入**
   - 只更新变更的记录，降低磁盘 IO
   - 删除记录只做标记，定期压缩文件

4. **高性能锁**
   - .NET 9+ 的 `Lock` 类型
   - `SemaphoreSlim` 用于异步场景

5. **零分配优化**
   - `Span<T>` / `stackalloc` 临时缓冲区
   - `ArrayPool<byte>` 读取缓冲区复用
   - `FrozenDictionary` 元数据缓存
   - `CollectionsMarshal` 直接访问 List 内部数组

6. **完整异步支持**
   - 所有 I/O 操作支持 async/await
   - 支持 `CancellationToken`
   - `IAsyncDisposable` 实现

### 6.2 未来优化方向
1. **压缩/整理机制**（后台任务）
   - 监控文件碎片率
   - 自动回收已删除记录空间

2. **内存索引**（可选）
   - `Dictionary<Id, Entity>` 加速查找
   - 仅在需要时创建

3. **批量操作优化**
   - 批量插入/更新/删除的专用API
   - 减少锁获取次数

---

## 7. 开发阶段计划

### 阶段 1（核心可用版）✅ 已完成
- MicroDbContext（初始化/加载/SaveChanges）
- DbSet<TEntity>
- ChangeTracker（增量记录）
- Lock / SemaphoreSlim（并发控制）
- StorageManager（固定长度二进制编解码、增量写入）
- SharedDataCache（跨 DbContext 共享内存）
- FileWriteQueue（单线程文件写入队列）

### 阶段 2（优化版）✅ 已完成
- 字段映射缓存（FrozenDictionary）
- Span<T> / stackalloc 零分配优化
- ArrayPool 缓冲区复用
- 完整异步支持（SaveChangesAsync）
- IAsyncDisposable 实现

### 阶段 3（扩展版）🔄 进行中
- ✅ 性能基准测试
- ✅ 全面的单元测试
- ⬜ 文件压缩工具
- ⬜ 表结构自动注册
- ⬜ 内存索引（可选）

### 阶段 4（高级功能）📋 计划中
- ⬜ 跨平台数据同步（选做）
- ⬜ EF Core Provider 接入（选做）
- ⬜ 数据迁移工具

---

## 8. 关键技术决策

### 8.1 为什么使用共享内存架构？
**问题**：每个 DbContext 实例都加载一份数据会导致：
- 内存浪费（同一文件被加载多次）
- 数据不一致（不同实例看到不同的数据状态）
- 同步复杂（需要手动刷新缓存）

**解决方案**：
- 使用静态的 `SharedDataCache` 管理所有文件的缓存
- 同一文件只有一个 `FileDataCache` 实例
- 所有 DbContext 实例共享同一份内存数据
- DbContext 销毁时不释放共享缓存

### 8.2 为什么需要 FileWriteQueue？
**问题**：多线程直接操作文件会导致：
- 文件句柄竞争和锁冲突
- 写入顺序不确定
- 数据损坏风险

**解决方案**：
- 所有文件写入通过 `Channel<WriteOperation>` 排队
- 单个后台线程串行执行所有写入
- 调用者通过 `TaskCompletionSource` 等待完成
- 保证写入顺序和数据一致性

### 8.3 为什么不自动释放缓存？
**设计理念**：
- 内存缓存的生命周期**独立于** DbContext 实例
- 短期内频繁创建/销毁 DbContext 不会导致重复加载
- 类似于静态变量或单例模式
- 用户需要时通过 `ReleaseSharedCache()` 显式释放

---

## 附录：架构对比

### 传统架构（已废弃）
```
DbContext #1 ──┐
               ├── 各自加载内存数据
DbContext #2 ──┤   各自持有读写锁
               ├── 各自操作文件
DbContext #3 ──┘
```
问题：内存浪费、数据不一致、文件锁冲突

### 当前架构（推荐）
```
SharedDataCache (静态)
    ↓
FileDataCache (单例/文件)
    ├── 共享内存数据
    ├── 共享读写锁
    └── FileWriteQueue (单线程)
    ↓
DbContext #1 ──┐
DbContext #2 ──┼── 共享访问
DbContext #3 ──┘
```
优势：内存高效、数据一致、线程安全

---

## ✅ 结论
当前版本已实现：
- ✅ 共享内存架构，避免重复加载
- ✅ 单线程文件写入队列，保证数据一致性
- ✅ 完整的异步支持（async/await）
- ✅ 高性能优化（Span、ArrayPool、FrozenDictionary）
- ✅ 固定长度二进制存储，O(1) 寻址
- ✅ 支持的数据类型：int、bool、string、decimal、DateTime 及其可空版本
- ✅ 多线程安全（Lock + SemaphoreSlim）
- ✅ 增量更新机制

适用于：
- 需要频繁读写的桌面应用
- 需要多个上下文实例协同工作的场景
- 数据量 ≤50MB 的本地存储
- 需要高性能和低延迟的应用